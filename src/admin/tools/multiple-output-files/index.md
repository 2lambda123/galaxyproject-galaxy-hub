---
title: Strategies for tools that create more than one output file
---
# Handling Multiple Output Files in Galaxy

Tools which create more than one output file are common.  There are several different methods to accommodate this need.  Each one of these has their advantages and weaknesses; careful thought should be employed to determine the best method for a particular tool.

## Static Multiple Outputs

Handling cases when tools create a static number of outputs is simple.  Simply include an <output> tag for each output desired within the tool XML file:

```xml
<tool id="example_tool" name="Multiple output" description="example">
    <command>example_tool.sh $input1 $tool_option1 $output1 $output2</command>
    <inputs>
        ...
    </inputs>
    ...
    <outputs>
        <data format="interval" name="output1" metadata_source="input1" />
        <data format="pdf" name="output2" />
    </outputs>
</tool>
```


## Variable Static Outputs determined by parameter values

In cases when the number of output files varies, but can be determined based upon a user's parameter selection, the use of the filter tag can be used.  The text contents of the <filter> tag are **eval**ed and if the expression is True a dataset will be created as normal.  If the expression is False, the output dataset will not be created; instead a NoneDataset object will be created and made available - when used on the command line the text **None** will appear instead of a file path. The local namespace of the filter has been populated with the tool parameters.


```xml
<tool id="example_tool" name="Multiple output" description="example">
    <command>example_tool.sh $input1 $tool_option1 $output1 $output2</command>
    <inputs>
       ...
       <param name="tool_option1" type="select" label="Type of output">
           <option value="1">Single File</option>
           <option value="2">Two Files</option>
       </param>
       <conditional name="condition1">
           <param name="tool_option2" type="select" label="Conditional output">
               <option value="yes">Yes</option>
               <option value="no">No</option>
           </param>
           ...
       </condition>
       ...
    </inputs>
    ...
    <outputs>
        <data format="interval" name="output1" metadata_source="input1" />
        <data format="pdf" name="output2" >
            <filter>tool_option1 == "2"</filter>
        </data>
        <data format="txt" name="output3" >
            <filter>condition1['tool_option2'] == "yes"</filter>
        </data>
    </outputs>
</tool>
```


The command line generated when **tool_option1** is set to **Single File** is:

```
example_tool.sh input1_FILE_PATH 1 output1_FILE_PATH None
```



The command line generated when **tool_option1** is set to **Two Files** is:

```
example_tool.sh input1_FILE_PATH 2 output1_FILE_PATH output2_FILE_PATH
```


The datatype of an output can be determined by conditional parameter settings as in  tools/filter/pasteWrapper.xml

```xml
 <outputs>
   <data format="input" name="out_file1" metadata_source="input1">
     <change_format>
       <when input_dataset="input1" attribute="ext" value="bed" format="interval"/>
     </change_format>
   </data>
 </outputs>
```


## Single history output Html file with links to any number of output files and images

There are times when a single history item is desired, but this history item is composed of multiple files which are only useful when considered together. This is done by having a single (**primary**) output and storing additional files in a directory (single-level) associated with the primary dataset.

A common usage of this strategy is to have the primary dataset be an HTML file and then store additional content (reports, pdfs, images, etc) in the dataset extra files directory. The content of this directory can be referenced using relative links with in the primary (HTML) file, clicking on the eye icon to view the dataset will display the HTML page.

If you want to wrap or create a tool that generates an html history item that shows the user links to a number of related output objects (files, images..), you need to know where to write the objects and how to reference them when your tool generates html which gets written to the html file. Galaxy will not write that html for you at present.

The fastqc wrapper (see tools/rgenetics/rg`FastQC`.py) is an existing tool example where the java application generates html and image outputs but these need to be massaged to make them Galaxy friendly. In other cases, the application or your wrapper must take care of all the fiddly detailed work of writing valid html to display to the user. In either situation, the Html datatype offers a flexible way to display very complex collections of related outputs inside a single history item or to present a complex html page generated by an application. There are some things you need to take care of for this to work:

### Use an html output file

If you want to the tool to write a single output in the history showing links to lots of files and/or images, use an Html datatype as the only output for the tool in the xml wrapper. eg:
```
<outputs>
<data format="html" name="html_file" label="myToolOutput_${tool_name}.html">
</outputs>
```


### Pass the application a specific output directory

The application or script must be set up to write all the output files and/or images to a new special subdirectory passed as a command line parameter from Galaxy every time the tool is run. The paths for images and other files will end up looking something like galaxy_dist/database/files/000/dataset_56/img1.jpg when you prepend the Galaxy provided path to the filenames you want to use. The command line must pass that path to your script and it is specified using the files_path property of the html file output. For example:
```
<command>myscript.pl "$input1" "$html_file" "$html_file.files_path" </command>
```


### Write valid html

The application must create and write valid html to setup the page `$html_file` seen by the user when they view (eye icon) the file. It must create and write that new file at the path passed by Galaxy as the `$html_file` command line parameter. All application outputs that will be included as links in that html code should be placed in the specific output directory `$html_file.files_path` passed on the command line. The external application is responsible for creating that directory before writing images and files into it. When generating the html, The files written by the application to `$html_file.files_path` are referenced in links directly by their name, without any other path decoration - eg:
```
<a href="file1.xls">Some special output</a>
<br/>
<img src="image1.jpg" >
```


The Galaxy Tool Factory includes code to gather all output files and create a page with links and clickable pdf thumbnail images which may be useful as a starting point - eg see https://bitbucket.org/fubar/rgalaxy/src/9932187787e592238c2c6fb514a39ff3a705a9af/tools/rgenetics/rgToolFactory.py?at=default

### Composite Datatypes

Html is a subclass of composite datasets so new subclasses of composite can be used to implement even more specific structured outputs (as seen with Rgenetics) but this requires adding the new definition to Galaxy - whereas Html files require no extension of the core framework. For more information visit [CompositeDatatypes](/src/admin/datatypes/Composite Datatypes/index.md).

## Number of Output datasets cannot be determined until tool run

There are times when the number of output datasets varies entirely based upon the inputs and cannot be determined ahead of time. Tools can be configured to "discover" an arbitrary number of files that will be added after the job's completion to the user's history as new datasets. There are a couple of options to handle this special case: dataset collections (workflow compatible), and regular datasets (not workflow compatible.) Whenever possible you should prefer dataset collections or one of the previously mentioned methods, so your tool can be used in workflows.

### Dataset Collections

Discovered Datasets can also be combined with dataset collections as shown in: [Galaxy Tool Generating Dataset Collections](https://web.science.mq.edu.au/~cassidy/2015/10/21/galaxy-tool-generating-datasets/)

While not yet fully documented here, there are extensive [test cases](https://github.com/galaxyproject/galaxy/tree/release_17.01/test/functional/tools) which cover datasets collections. These are generally the best reference for how to build various types of dataset collections.

### Non-Dataset Collections

Discovering datasets require a fixed 'parent' output dataset - this dataset will act as the reference for our additional datasets. By default, this appears as an empty dataset that is output. Many tool authors use this as a text report / log of the tool run, otherwise users may think that something is wrong when the first dataset is empty.

Discovered datasets require a unique designation (i.e. the default output name). Your tool should write these datasets to be discovered out to the current working directory, or to a subdirectory thereof. Regular expressions may be used in the dataset discovery statement.

#### Examples

Consider a tool that creates a bunch of text files or bam files. To allow this tool to work with `discover_datasets`, the tool should be configured to write them to a subdirectory. We have arbitrarily chosen our subdirectory name as `split`. During the tool run, it will write the bam and text files into that directory, with the appropriate extension. The tool can then be configured to discover the outputs with the following XML:

```xml
<outputs>
  <data format="txt" name="report">
    <discover_datasets pattern="__designation_and_ext__" directory="split" visible="true" />
  </data>
</outputs>
```

If the tool produced the following files when it was run:

- `split/samp1.bam`
- `split/samp2.bam`
- `split/samp3.bam`
- `split/samp4.bam`
- `split/cross1.txt`
- `split/cross2.txt`

Then 6 datasets would be discovered and added to the history. The `<discover_datasets>` block would look in `directory="split"` and find a number of files which all match the generic `pattern="__designation_and_ext__"`. These files would show up in your Galaxy history as `My Tool (Samp1.bam)`, `My Tool (Samp2.bam)`, and so on. Since we have used `__designation_and_ext__`, galaxy will see the `.bam` and `.txt` extensions and set the filetype appropriately.

If for some reason a different or incorrect file extension was used, such as a tool which writes out `.tsv` files, Galaxy would not know how to handle those as tabular datasets. In that case, instead of `__designation_and_ext__`, we can use `__designation__` and the `ext` option:

```xml
<outputs>
  <data format="txt" name="report">
    <discover_datasets pattern="__designation__" ext="tabular" directory="tables" visible="true" />
  </data>
</outputs>
```

In this example, if the tool created 3 tabular files such as `tables/part1.tsv`, `tables/part2.tsv`, and `tables/part3.tsv` - then 3 datasets will be discovered, all with the type `tabular` and with dataset names like `My Tool (part1.tsv)`, `My Tool (part2.tsv)`, and `My Tool (part3.tsv)`.

##### Customizing the Name

If you do not want `My Tool (...)` to be part of the history dataset name, you can replace `designation` with `name`. So `__designation_and_ext__` would be replaced by `__name_and_ext__` and `__designation__` would be replaced by `__name__`.

##### Hiding the Extension

It may not be desirable for the extension (`.tsv`) to appear in the `designation` this way. These patterns `__designation__` and  `__designation_and_ext__` can be replaced with regular expressions that capture metadata from the file name using named groups. `__designation__` and `__designation_and_ext__` are just shortcuts, for `(?P<designation>.*)` and  `(?P<designation>.*)\.(?P<ext>[^\._]+)?`, respectively. If you need, you can override these by manually specifying the regular expressions using the `pattern` optin in your `discover_datasets` block. The above example can be modified as:

```xml
<outputs>
  <data format="txt" name="report">
    <discover_datasets pattern="(?P&lt;designation&gt;.+)\.tsv" ext="tabular" directory="tables" visible="true" />
  </data>
</outputs>
```

Going back to our `tables/part{1,2,3}.tsv` example, all three datasets are still be captured but this time with designations of `part1`, `part2`, and `part3`.

Notice here the `<` and `>` in the tool pattern had to be replaced with `\&lt;` and `&gt;` to be properly embedded in XML.

#### More Metadata

There are more metadata elements which can be captured:

- `ext`
- `designation`
- `name`
- `dbkey`
- `visible`

Each pattern must declare at least either a `designation` or a `name` - the other metadata parts `ext`, `dbkey`, and `visible` are all optional and may also be declared explicitly in via attributes on the `discover_datasets` element (as shown in the above examples).

If no `discover_datasets` element is nested with a tool output - Galaxy will still look for datasets using the named pattern `__default__` which expands to `primary_DATASET_ID_(?P<designation>[^_]+)_(?P<visible>[^_]+)_(?P<ext>[^_]+)(_(?P<dbkey>[^_]+))?`. Many tools use this mechanism as it traditionally was the only way to discover datasets.

For instance consider the following output declaration:

```xml
<outputs>
  <data format="interval" name="output1" metadata_source="input1" />
</outputs>
```

If `$output1.id` (accessible in the tool `command` block) is `546` and the tool produces the files `primary_546_output2_visible_bed` and `primary_546_output3_visible_pdf` in the job's working directory - then after execution is complete these two additional datasets (a bed file and a pdf file) are added to the user's history.

More information:

* [Contrived example tool with demonstration of more patterns and testing of discovered outputs](https://github.com/galaxyproject/galaxy/blob/release_17.01/test/functional/tools/multi_output_configured.xml)
* [Original pull request for discovered dataset enhancements with implementation details](http://bit.ly/gxdiscovereddatasetpr)
* [Implementation of output collection code in galaxy-central](https://github.com/galaxyproject/galaxy/blob/master/lib/galaxy/tools/parameters/output_collect.py)

#### Legacy information:

**`force_history_refresh` is deprecated.** In the past, it would be necessary to set the attribute `force_history_refresh` to `True` to force the user's history to fully refresh after the tool run has completed. This functionality is now broken and `force_history_refresh` is ignored by Galaxy. Users now //**`MUST`**// manually refresh their history to see these files. A Trello card used to track the progress on fixing this and eliminating the need to refresh histories in this manner can be found [here](https://trello.com/c/f5Ddv4CS/1993-history-api-determine-history-state-running-from-join-on-running-jobs).

Discovered datasets are available via post job hooks (a deprecated feature) by using the designation - e.g. `__collected_datasets__['primary'][designation]`.

In the past these datasets were typically written to `$__new_file_path__` instead of the working directory. This is not very scalable and `$__new_file_path__` should generally not be used. If you set the option `collect_outputs_from` in `galaxy.ini` ensure `job_working_directory` is listed as an option (if not the only option).
